// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/artefact/artefact.proto
// DO NOT EDIT!

/*
Package artefact is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/artefact/artefact.proto

It has these top-level messages:
	ArtefactList
	DownloadRequest
	FileStream
	Reference
	ArtefactRef
	SerialReference
	Contents
	SetAccessRequest
	ArtefactID
	FindRequest
	GetVersionRequest
*/
package artefact

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import h2gproxy "golang.conradwood.net/apis/h2gproxy"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ContentType int32

const (
	ContentType_Directory ContentType = 0
	ContentType_File      ContentType = 1
	ContentType_Artefact  ContentType = 2
)

var ContentType_name = map[int32]string{
	0: "Directory",
	1: "File",
	2: "Artefact",
}
var ContentType_value = map[string]int32{
	"Directory": 0,
	"File":      1,
	"Artefact":  2,
}

func (x ContentType) String() string {
	return proto.EnumName(ContentType_name, int32(x))
}
func (ContentType) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type ArtefactList struct {
	Artefacts []*Contents `protobuf:"bytes,1,rep,name=Artefacts" json:"Artefacts,omitempty"`
}

func (m *ArtefactList) Reset()                    { *m = ArtefactList{} }
func (m *ArtefactList) String() string            { return proto.CompactTextString(m) }
func (*ArtefactList) ProtoMessage()               {}
func (*ArtefactList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ArtefactList) GetArtefacts() []*Contents {
	if m != nil {
		return m.Artefacts
	}
	return nil
}

type DownloadRequest struct {
	Reference string `protobuf:"bytes,1,opt,name=Reference" json:"Reference,omitempty"`
}

func (m *DownloadRequest) Reset()                    { *m = DownloadRequest{} }
func (m *DownloadRequest) String() string            { return proto.CompactTextString(m) }
func (*DownloadRequest) ProtoMessage()               {}
func (*DownloadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DownloadRequest) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

type FileStream struct {
	Data []byte `protobuf:"bytes,1,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *FileStream) Reset()                    { *m = FileStream{} }
func (m *FileStream) String() string            { return proto.CompactTextString(m) }
func (*FileStream) ProtoMessage()               {}
func (*FileStream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *FileStream) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type Reference struct {
	Reference string `protobuf:"bytes,1,opt,name=Reference" json:"Reference,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (m *Reference) String() string            { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Reference) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

type ArtefactRef struct {
	Name    string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Version uint64 `protobuf:"varint,2,opt,name=Version" json:"Version,omitempty"`
}

func (m *ArtefactRef) Reset()                    { *m = ArtefactRef{} }
func (m *ArtefactRef) String() string            { return proto.CompactTextString(m) }
func (*ArtefactRef) ProtoMessage()               {}
func (*ArtefactRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ArtefactRef) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ArtefactRef) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

type SerialReference struct {
	RefType   uint32   `protobuf:"varint,1,opt,name=RefType" json:"RefType,omitempty"`
	Version   uint64   `protobuf:"varint,2,opt,name=Version" json:"Version,omitempty"`
	Texts     []string `protobuf:"bytes,3,rep,name=Texts" json:"Texts,omitempty"`
	Domain    string   `protobuf:"bytes,4,opt,name=Domain" json:"Domain,omitempty"`
	BuildRepo string   `protobuf:"bytes,5,opt,name=BuildRepo" json:"BuildRepo,omitempty"`
}

func (m *SerialReference) Reset()                    { *m = SerialReference{} }
func (m *SerialReference) String() string            { return proto.CompactTextString(m) }
func (*SerialReference) ProtoMessage()               {}
func (*SerialReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *SerialReference) GetRefType() uint32 {
	if m != nil {
		return m.RefType
	}
	return 0
}

func (m *SerialReference) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SerialReference) GetTexts() []string {
	if m != nil {
		return m.Texts
	}
	return nil
}

func (m *SerialReference) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *SerialReference) GetBuildRepo() string {
	if m != nil {
		return m.BuildRepo
	}
	return ""
}

type Contents struct {
	ReferenceVersion string       `protobuf:"bytes,1,opt,name=ReferenceVersion" json:"ReferenceVersion,omitempty"`
	ReferenceLatest  string       `protobuf:"bytes,2,opt,name=ReferenceLatest" json:"ReferenceLatest,omitempty"`
	Entries          []*Contents  `protobuf:"bytes,3,rep,name=Entries" json:"Entries,omitempty"`
	Name             string       `protobuf:"bytes,4,opt,name=Name" json:"Name,omitempty"`
	Version          uint64       `protobuf:"varint,5,opt,name=Version" json:"Version,omitempty"`
	AdminAccess      bool         `protobuf:"varint,6,opt,name=AdminAccess" json:"AdminAccess,omitempty"`
	Type             ContentType  `protobuf:"varint,7,opt,name=Type,enum=artefact.ContentType" json:"Type,omitempty"`
	Artefact         *ArtefactRef `protobuf:"bytes,8,opt,name=Artefact" json:"Artefact,omitempty"`
	Path             string       `protobuf:"bytes,9,opt,name=Path" json:"Path,omitempty"`
	Downloadable     bool         `protobuf:"varint,10,opt,name=Downloadable" json:"Downloadable,omitempty"`
	// the name of an artefact is not entirely sufficient. we may have multiple buildrepo servers too
	Domain       string      `protobuf:"bytes,11,opt,name=Domain" json:"Domain,omitempty"`
	ArtefactID   *ArtefactID `protobuf:"bytes,12,opt,name=ArtefactID" json:"ArtefactID,omitempty"`
	BuildRepo    string      `protobuf:"bytes,13,opt,name=BuildRepo" json:"BuildRepo,omitempty"`
	RepositoryID uint64      `protobuf:"varint,14,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
}

func (m *Contents) Reset()                    { *m = Contents{} }
func (m *Contents) String() string            { return proto.CompactTextString(m) }
func (*Contents) ProtoMessage()               {}
func (*Contents) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Contents) GetReferenceVersion() string {
	if m != nil {
		return m.ReferenceVersion
	}
	return ""
}

func (m *Contents) GetReferenceLatest() string {
	if m != nil {
		return m.ReferenceLatest
	}
	return ""
}

func (m *Contents) GetEntries() []*Contents {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *Contents) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Contents) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Contents) GetAdminAccess() bool {
	if m != nil {
		return m.AdminAccess
	}
	return false
}

func (m *Contents) GetType() ContentType {
	if m != nil {
		return m.Type
	}
	return ContentType_Directory
}

func (m *Contents) GetArtefact() *ArtefactRef {
	if m != nil {
		return m.Artefact
	}
	return nil
}

func (m *Contents) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Contents) GetDownloadable() bool {
	if m != nil {
		return m.Downloadable
	}
	return false
}

func (m *Contents) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *Contents) GetArtefactID() *ArtefactID {
	if m != nil {
		return m.ArtefactID
	}
	return nil
}

func (m *Contents) GetBuildRepo() string {
	if m != nil {
		return m.BuildRepo
	}
	return ""
}

func (m *Contents) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

type SetAccessRequest struct {
	Target *Reference `protobuf:"bytes,1,opt,name=Target" json:"Target,omitempty"`
	UserID string     `protobuf:"bytes,2,opt,name=UserID" json:"UserID,omitempty"`
	Grant  bool       `protobuf:"varint,3,opt,name=Grant" json:"Grant,omitempty"`
}

func (m *SetAccessRequest) Reset()                    { *m = SetAccessRequest{} }
func (m *SetAccessRequest) String() string            { return proto.CompactTextString(m) }
func (*SetAccessRequest) ProtoMessage()               {}
func (*SetAccessRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SetAccessRequest) GetTarget() *Reference {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *SetAccessRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *SetAccessRequest) GetGrant() bool {
	if m != nil {
		return m.Grant
	}
	return false
}

// for database
type ArtefactID struct {
	ID     uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Domain string `protobuf:"bytes,2,opt,name=Domain" json:"Domain,omitempty"`
	Name   string `protobuf:"bytes,3,opt,name=Name" json:"Name,omitempty"`
}

func (m *ArtefactID) Reset()                    { *m = ArtefactID{} }
func (m *ArtefactID) String() string            { return proto.CompactTextString(m) }
func (*ArtefactID) ProtoMessage()               {}
func (*ArtefactID) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ArtefactID) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ArtefactID) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *ArtefactID) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type FindRequest struct {
	// only return results containing this
	NameMatch string `protobuf:"bytes,1,opt,name=NameMatch" json:"NameMatch,omitempty"`
}

func (m *FindRequest) Reset()                    { *m = FindRequest{} }
func (m *FindRequest) String() string            { return proto.CompactTextString(m) }
func (*FindRequest) ProtoMessage()               {}
func (*FindRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *FindRequest) GetNameMatch() string {
	if m != nil {
		return m.NameMatch
	}
	return ""
}

type GetVersionRequest struct {
	Name    string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Domain  string `protobuf:"bytes,2,opt,name=Domain" json:"Domain,omitempty"`
	Version uint64 `protobuf:"varint,3,opt,name=Version" json:"Version,omitempty"`
}

func (m *GetVersionRequest) Reset()                    { *m = GetVersionRequest{} }
func (m *GetVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*GetVersionRequest) ProtoMessage()               {}
func (*GetVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GetVersionRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GetVersionRequest) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *GetVersionRequest) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func init() {
	proto.RegisterType((*ArtefactList)(nil), "artefact.ArtefactList")
	proto.RegisterType((*DownloadRequest)(nil), "artefact.DownloadRequest")
	proto.RegisterType((*FileStream)(nil), "artefact.FileStream")
	proto.RegisterType((*Reference)(nil), "artefact.Reference")
	proto.RegisterType((*ArtefactRef)(nil), "artefact.ArtefactRef")
	proto.RegisterType((*SerialReference)(nil), "artefact.SerialReference")
	proto.RegisterType((*Contents)(nil), "artefact.Contents")
	proto.RegisterType((*SetAccessRequest)(nil), "artefact.SetAccessRequest")
	proto.RegisterType((*ArtefactID)(nil), "artefact.ArtefactID")
	proto.RegisterType((*FindRequest)(nil), "artefact.FindRequest")
	proto.RegisterType((*GetVersionRequest)(nil), "artefact.GetVersionRequest")
	proto.RegisterEnum("artefact.ContentType", ContentType_name, ContentType_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for ArtefactService service

type ArtefactServiceClient interface {
	// list *latest* version of all artefacts (for this user)
	List(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ArtefactList, error)
	// get contents of a directory or artefact.
	GetContents(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Contents, error)
	// download a file via http
	StreamHTTP(ctx context.Context, in *h2gproxy.StreamRequest, opts ...grpc.CallOption) (ArtefactService_StreamHTTPClient, error)
	// download a file via gRPC
	GetFile(ctx context.Context, in *Reference, opts ...grpc.CallOption) (ArtefactService_GetFileClient, error)
	// set access to a repo/artefact
	SetAccess(ctx context.Context, in *SetAccessRequest, opts ...grpc.CallOption) (*common.Void, error)
	// finds artefacts based on fuzzy string matches
	Find(ctx context.Context, in *FindRequest, opts ...grpc.CallOption) (*ArtefactList, error)
	// get a specific version of a repository
	GetRepoVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*Contents, error)
}

type artefactServiceClient struct {
	cc *grpc.ClientConn
}

func NewArtefactServiceClient(cc *grpc.ClientConn) ArtefactServiceClient {
	return &artefactServiceClient{cc}
}

func (c *artefactServiceClient) List(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ArtefactList, error) {
	out := new(ArtefactList)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/List", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetContents(ctx context.Context, in *Reference, opts ...grpc.CallOption) (*Contents, error) {
	out := new(Contents)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetContents", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) StreamHTTP(ctx context.Context, in *h2gproxy.StreamRequest, opts ...grpc.CallOption) (ArtefactService_StreamHTTPClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ArtefactService_serviceDesc.Streams[0], c.cc, "/artefact.ArtefactService/StreamHTTP", opts...)
	if err != nil {
		return nil, err
	}
	x := &artefactServiceStreamHTTPClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ArtefactService_StreamHTTPClient interface {
	Recv() (*h2gproxy.StreamDataResponse, error)
	grpc.ClientStream
}

type artefactServiceStreamHTTPClient struct {
	grpc.ClientStream
}

func (x *artefactServiceStreamHTTPClient) Recv() (*h2gproxy.StreamDataResponse, error) {
	m := new(h2gproxy.StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *artefactServiceClient) GetFile(ctx context.Context, in *Reference, opts ...grpc.CallOption) (ArtefactService_GetFileClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ArtefactService_serviceDesc.Streams[1], c.cc, "/artefact.ArtefactService/GetFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &artefactServiceGetFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ArtefactService_GetFileClient interface {
	Recv() (*h2gproxy.StreamDataResponse, error)
	grpc.ClientStream
}

type artefactServiceGetFileClient struct {
	grpc.ClientStream
}

func (x *artefactServiceGetFileClient) Recv() (*h2gproxy.StreamDataResponse, error) {
	m := new(h2gproxy.StreamDataResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *artefactServiceClient) SetAccess(ctx context.Context, in *SetAccessRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/SetAccess", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) Find(ctx context.Context, in *FindRequest, opts ...grpc.CallOption) (*ArtefactList, error) {
	out := new(ArtefactList)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/Find", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *artefactServiceClient) GetRepoVersion(ctx context.Context, in *GetVersionRequest, opts ...grpc.CallOption) (*Contents, error) {
	out := new(Contents)
	err := grpc.Invoke(ctx, "/artefact.ArtefactService/GetRepoVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for ArtefactService service

type ArtefactServiceServer interface {
	// list *latest* version of all artefacts (for this user)
	List(context.Context, *common.Void) (*ArtefactList, error)
	// get contents of a directory or artefact.
	GetContents(context.Context, *Reference) (*Contents, error)
	// download a file via http
	StreamHTTP(*h2gproxy.StreamRequest, ArtefactService_StreamHTTPServer) error
	// download a file via gRPC
	GetFile(*Reference, ArtefactService_GetFileServer) error
	// set access to a repo/artefact
	SetAccess(context.Context, *SetAccessRequest) (*common.Void, error)
	// finds artefacts based on fuzzy string matches
	Find(context.Context, *FindRequest) (*ArtefactList, error)
	// get a specific version of a repository
	GetRepoVersion(context.Context, *GetVersionRequest) (*Contents, error)
}

func RegisterArtefactServiceServer(s *grpc.Server, srv ArtefactServiceServer) {
	s.RegisterService(&_ArtefactService_serviceDesc, srv)
}

func _ArtefactService_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/List",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).List(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetContents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Reference)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetContents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetContents",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetContents(ctx, req.(*Reference))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_StreamHTTP_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(h2gproxy.StreamRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArtefactServiceServer).StreamHTTP(m, &artefactServiceStreamHTTPServer{stream})
}

type ArtefactService_StreamHTTPServer interface {
	Send(*h2gproxy.StreamDataResponse) error
	grpc.ServerStream
}

type artefactServiceStreamHTTPServer struct {
	grpc.ServerStream
}

func (x *artefactServiceStreamHTTPServer) Send(m *h2gproxy.StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ArtefactService_GetFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Reference)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ArtefactServiceServer).GetFile(m, &artefactServiceGetFileServer{stream})
}

type ArtefactService_GetFileServer interface {
	Send(*h2gproxy.StreamDataResponse) error
	grpc.ServerStream
}

type artefactServiceGetFileServer struct {
	grpc.ServerStream
}

func (x *artefactServiceGetFileServer) Send(m *h2gproxy.StreamDataResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _ArtefactService_SetAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetAccessRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).SetAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/SetAccess",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).SetAccess(ctx, req.(*SetAccessRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_Find_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).Find(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/Find",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).Find(ctx, req.(*FindRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ArtefactService_GetRepoVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ArtefactServiceServer).GetRepoVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/artefact.ArtefactService/GetRepoVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ArtefactServiceServer).GetRepoVersion(ctx, req.(*GetVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ArtefactService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "artefact.ArtefactService",
	HandlerType: (*ArtefactServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _ArtefactService_List_Handler,
		},
		{
			MethodName: "GetContents",
			Handler:    _ArtefactService_GetContents_Handler,
		},
		{
			MethodName: "SetAccess",
			Handler:    _ArtefactService_SetAccess_Handler,
		},
		{
			MethodName: "Find",
			Handler:    _ArtefactService_Find_Handler,
		},
		{
			MethodName: "GetRepoVersion",
			Handler:    _ArtefactService_GetRepoVersion_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamHTTP",
			Handler:       _ArtefactService_StreamHTTP_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "GetFile",
			Handler:       _ArtefactService_GetFile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "golang.conradwood.net/apis/artefact/artefact.proto",
}

func init() { proto.RegisterFile("golang.conradwood.net/apis/artefact/artefact.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 796 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x84, 0x55, 0xdd, 0xae, 0xda, 0x46,
	0x10, 0xae, 0xc1, 0x07, 0xf0, 0x98, 0x03, 0x74, 0x9b, 0xa6, 0x16, 0xcd, 0x85, 0xe5, 0xaa, 0x92,
	0xf3, 0x23, 0x4e, 0x4a, 0x93, 0xde, 0x54, 0xaa, 0x4a, 0xea, 0x84, 0x20, 0xa5, 0x55, 0xb4, 0xd0,
	0x48, 0xbd, 0xdc, 0x98, 0x81, 0x63, 0x09, 0x76, 0xa9, 0xbd, 0x69, 0x72, 0xee, 0xfb, 0x02, 0x7d,
	0x92, 0xbe, 0x62, 0xb4, 0x6b, 0xaf, 0x7f, 0x80, 0x93, 0x5c, 0x79, 0x67, 0x3c, 0xbb, 0xf3, 0xed,
	0x37, 0xdf, 0xcc, 0xc2, 0x74, 0x2b, 0x76, 0x8c, 0x6f, 0x27, 0xb1, 0xe0, 0x29, 0x5b, 0xbf, 0x17,
	0x62, 0x3d, 0xe1, 0x28, 0xaf, 0xd8, 0x21, 0xc9, 0xae, 0x58, 0x2a, 0x71, 0xc3, 0x62, 0x59, 0x2e,
	0x26, 0x87, 0x54, 0x48, 0x41, 0x7a, 0xc6, 0x1e, 0x4f, 0x3e, 0xb1, 0x3b, 0x16, 0xfb, 0xbd, 0xe0,
	0xc5, 0x27, 0xdf, 0x39, 0xfe, 0x54, 0xb6, 0xeb, 0xe9, 0xf6, 0x90, 0x8a, 0x0f, 0x37, 0xe5, 0x22,
	0xdf, 0x13, 0xfc, 0x0a, 0xfd, 0x59, 0x91, 0xef, 0x55, 0x92, 0x49, 0xf2, 0x18, 0x1c, 0x63, 0x67,
	0x9e, 0xe5, 0xb7, 0x43, 0x77, 0x4a, 0x26, 0x25, 0xc2, 0xdf, 0x04, 0x97, 0xc8, 0x65, 0x46, 0xab,
	0xa0, 0xe0, 0x0a, 0x86, 0x91, 0x78, 0xcf, 0x77, 0x82, 0xad, 0x29, 0xfe, 0xfd, 0x0e, 0x33, 0x49,
	0xee, 0x81, 0x43, 0x71, 0x83, 0x29, 0xf2, 0x18, 0x3d, 0xcb, 0xb7, 0x42, 0x87, 0x56, 0x8e, 0xc0,
	0x07, 0x78, 0x91, 0xec, 0x70, 0x29, 0x53, 0x64, 0x7b, 0x42, 0xc0, 0x8e, 0x98, 0x64, 0x3a, 0xac,
	0x4f, 0xf5, 0x3a, 0xb8, 0x5f, 0xdb, 0xff, 0x99, 0xc3, 0x7e, 0x06, 0xd7, 0x40, 0xa1, 0xb8, 0x51,
	0xa7, 0xfd, 0xc1, 0xf6, 0x26, 0x4e, 0xaf, 0x89, 0x07, 0xdd, 0x37, 0x98, 0x66, 0x89, 0xe0, 0x5e,
	0xcb, 0xb7, 0x42, 0x9b, 0x1a, 0x33, 0xf8, 0xcf, 0x82, 0xe1, 0x12, 0xd3, 0x84, 0xed, 0xaa, 0x74,
	0x1e, 0x74, 0x29, 0x6e, 0x56, 0x37, 0x87, 0xfc, 0x90, 0x4b, 0x6a, 0xcc, 0xdb, 0xcf, 0x21, 0x77,
	0xe0, 0x62, 0x85, 0x1f, 0x64, 0xe6, 0xb5, 0xfd, 0x76, 0xe8, 0xd0, 0xdc, 0x20, 0x77, 0xa1, 0x13,
	0x89, 0x3d, 0x4b, 0xb8, 0x67, 0x6b, 0x34, 0x85, 0xa5, 0x2e, 0xf4, 0xec, 0x5d, 0xb2, 0x5b, 0x53,
	0x3c, 0x08, 0xef, 0x22, 0xbf, 0x50, 0xe9, 0x08, 0xfe, 0xb5, 0xa1, 0x67, 0x68, 0x26, 0x0f, 0x60,
	0x54, 0x22, 0x33, 0xb9, 0xf3, 0xab, 0x9d, 0xf8, 0x49, 0x08, 0xc3, 0xd2, 0xf7, 0x8a, 0x49, 0xcc,
	0xa4, 0x86, 0xe9, 0xd0, 0x63, 0x37, 0x79, 0x04, 0xdd, 0xe7, 0x5c, 0xa6, 0x09, 0xe6, 0x80, 0xcf,
	0x57, 0xd8, 0x84, 0x94, 0x94, 0xda, 0xe7, 0x29, 0xbd, 0x68, 0x52, 0xe1, 0x83, 0x3b, 0x5b, 0xef,
	0x13, 0x3e, 0x8b, 0x63, 0xcc, 0x32, 0xaf, 0xe3, 0x5b, 0x61, 0x8f, 0xd6, 0x5d, 0xe4, 0x3e, 0xd8,
	0x9a, 0xdd, 0xae, 0x6f, 0x85, 0x83, 0xe9, 0xd7, 0x27, 0xa9, 0xd5, 0x4f, 0xaa, 0x43, 0xc8, 0x0f,
	0xd0, 0x33, 0xc5, 0xf5, 0x7a, 0xbe, 0x15, 0xba, 0xf5, 0xf0, 0x5a, 0xd9, 0x69, 0x19, 0xa6, 0xd0,
	0xbe, 0x66, 0xf2, 0xda, 0x73, 0x72, 0xb4, 0x6a, 0x4d, 0x02, 0xe8, 0x1b, 0x85, 0xb2, 0xb7, 0x3b,
	0xf4, 0x40, 0x83, 0x6a, 0xf8, 0x6a, 0xc5, 0x72, 0x1b, 0xc5, 0x7a, 0x02, 0x60, 0xce, 0x5e, 0x44,
	0x5e, 0x5f, 0x83, 0xb8, 0x73, 0x0a, 0x62, 0x11, 0xd1, 0x5a, 0x5c, 0xb3, 0xc4, 0x97, 0x47, 0x25,
	0x56, 0x78, 0xd4, 0x37, 0x4b, 0xa4, 0x48, 0x6f, 0x16, 0x91, 0x37, 0xd0, 0x14, 0x36, 0x7c, 0xc1,
	0x1e, 0x46, 0x4b, 0x94, 0x39, 0x65, 0xa6, 0xad, 0x1e, 0x42, 0x67, 0xc5, 0xd2, 0x2d, 0x4a, 0xad,
	0x01, 0x77, 0xfa, 0x55, 0x85, 0xa3, 0x2c, 0x31, 0x2d, 0x42, 0xd4, 0x85, 0xfe, 0xcc, 0x30, 0x5d,
	0x44, 0x85, 0x0a, 0x0a, 0x4b, 0x69, 0x75, 0x9e, 0x32, 0x2e, 0xbd, 0xb6, 0x66, 0x21, 0x37, 0x82,
	0x97, 0xf5, 0x6b, 0x92, 0x01, 0xb4, 0x16, 0x91, 0x4e, 0x62, 0xd3, 0xd6, 0x22, 0xaa, 0x91, 0xd3,
	0x6a, 0x90, 0x63, 0xa4, 0xd1, 0xae, 0xa4, 0x11, 0x3c, 0x04, 0xf7, 0x45, 0xc2, 0xeb, 0xa3, 0x40,
	0xb9, 0x7f, 0x67, 0x32, 0xbe, 0x36, 0xdd, 0x5b, 0x3a, 0x82, 0xbf, 0xe0, 0xcb, 0x39, 0xca, 0x42,
	0x3b, 0x66, 0xcb, 0xb9, 0x1e, 0xbe, 0x0d, 0x41, 0x4d, 0x88, 0xed, 0x86, 0x10, 0x1f, 0x3c, 0x01,
	0xb7, 0x26, 0x28, 0x72, 0x09, 0x4e, 0x94, 0xa4, 0x18, 0x2b, 0x7a, 0x47, 0x5f, 0x90, 0x1e, 0xd8,
	0x6a, 0x06, 0x8d, 0x2c, 0xd2, 0xaf, 0x34, 0x36, 0x6a, 0x4d, 0xff, 0x6f, 0xc3, 0xd0, 0x98, 0x4b,
	0x4c, 0xff, 0x49, 0x62, 0x24, 0x8f, 0xc0, 0xd6, 0xa3, 0xb1, 0x3f, 0x29, 0xa6, 0xed, 0x1b, 0x91,
	0xac, 0xc7, 0x77, 0x4f, 0x45, 0xa0, 0xa3, 0x7e, 0x02, 0x77, 0x8e, 0xb2, 0xec, 0xe0, 0x73, 0x35,
	0x1a, 0x9f, 0xe9, 0x37, 0xf2, 0x1c, 0x20, 0x9f, 0x88, 0x2f, 0x57, 0xab, 0xd7, 0xe4, 0x9b, 0x49,
	0x39, 0xa7, 0x73, 0x6f, 0x41, 0xce, 0xf8, 0xde, 0xf1, 0x0f, 0x35, 0x30, 0x29, 0x66, 0x07, 0xc1,
	0x33, 0x7c, 0x6c, 0x91, 0x5f, 0xa0, 0x3b, 0x47, 0xa9, 0xee, 0x76, 0x3e, 0xf5, 0xe7, 0xf6, 0x3f,
	0x05, 0xa7, 0xd4, 0x1d, 0x19, 0x57, 0x27, 0x1c, 0x8b, 0x71, 0xdc, 0x60, 0x83, 0x3c, 0x55, 0x7c,
	0xf2, 0x35, 0xa9, 0xf5, 0x67, 0x4d, 0x05, 0xb7, 0x92, 0x35, 0x83, 0xc1, 0x1c, 0xa5, 0x12, 0xbe,
	0x99, 0x1f, 0xdf, 0x56, 0x91, 0x27, 0xca, 0x38, 0xc7, 0xdb, 0xb3, 0xef, 0xe1, 0x3b, 0x8e, 0xb2,
	0xfe, 0xe6, 0x15, 0xaf, 0xa0, 0x7a, 0xf6, 0xca, 0xf8, 0xb7, 0x1d, 0xfd, 0xdc, 0xfd, 0xf8, 0x31,
	0x00, 0x00, 0xff, 0xff, 0x35, 0xc0, 0xea, 0xad, 0x92, 0x07, 0x00, 0x00,
}
