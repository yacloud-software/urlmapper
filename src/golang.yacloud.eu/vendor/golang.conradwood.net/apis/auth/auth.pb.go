// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/auth/auth.proto
// DO NOT EDIT!

package auth

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type AuthResponse struct {
	Valid         bool   `protobuf:"varint,1,opt,name=Valid" json:"Valid,omitempty"`
	PublicMessage string `protobuf:"bytes,2,opt,name=PublicMessage" json:"PublicMessage,omitempty"`
	LogMessage    string `protobuf:"bytes,3,opt,name=LogMessage" json:"LogMessage,omitempty"`
	User          *User  `protobuf:"bytes,4,opt,name=User" json:"User,omitempty"`
	Token         string `protobuf:"bytes,5,opt,name=Token" json:"Token,omitempty"`
}

func (m *AuthResponse) Reset()                    { *m = AuthResponse{} }
func (m *AuthResponse) String() string            { return proto.CompactTextString(m) }
func (*AuthResponse) ProtoMessage()               {}
func (*AuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{0} }

func (m *AuthResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *AuthResponse) GetPublicMessage() string {
	if m != nil {
		return m.PublicMessage
	}
	return ""
}

func (m *AuthResponse) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

func (m *AuthResponse) GetUser() *User {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *AuthResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type SignedAuthResponse struct {
	Valid         bool        `protobuf:"varint,1,opt,name=Valid" json:"Valid,omitempty"`
	PublicMessage string      `protobuf:"bytes,2,opt,name=PublicMessage" json:"PublicMessage,omitempty"`
	LogMessage    string      `protobuf:"bytes,3,opt,name=LogMessage" json:"LogMessage,omitempty"`
	User          *SignedUser `protobuf:"bytes,4,opt,name=User" json:"User,omitempty"`
	Token         string      `protobuf:"bytes,5,opt,name=Token" json:"Token,omitempty"`
}

func (m *SignedAuthResponse) Reset()                    { *m = SignedAuthResponse{} }
func (m *SignedAuthResponse) String() string            { return proto.CompactTextString(m) }
func (*SignedAuthResponse) ProtoMessage()               {}
func (*SignedAuthResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{1} }

func (m *SignedAuthResponse) GetValid() bool {
	if m != nil {
		return m.Valid
	}
	return false
}

func (m *SignedAuthResponse) GetPublicMessage() string {
	if m != nil {
		return m.PublicMessage
	}
	return ""
}

func (m *SignedAuthResponse) GetLogMessage() string {
	if m != nil {
		return m.LogMessage
	}
	return ""
}

func (m *SignedAuthResponse) GetUser() *SignedUser {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *SignedAuthResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

//
// this message contains a serialised proto and the signature over the serialised proto
// we are migrating towards this, as it allows us to update the proto in future without
// breaking backwards compatibility. The Signature within SignedUser.User is non-defined
// and may contain random bytes or 0. The only guarantee is that go-easyops can verify it as valid.
type SignedUser struct {
	User      []byte `protobuf:"bytes,1,opt,name=User,proto3" json:"User,omitempty"`
	Signature []byte `protobuf:"bytes,2,opt,name=Signature,proto3" json:"Signature,omitempty"`
}

func (m *SignedUser) Reset()                    { *m = SignedUser{} }
func (m *SignedUser) String() string            { return proto.CompactTextString(m) }
func (*SignedUser) ProtoMessage()               {}
func (*SignedUser) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{2} }

func (m *SignedUser) GetUser() []byte {
	if m != nil {
		return m.User
	}
	return nil
}

func (m *SignedUser) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

//
// this message is cryptographically signed.
// Adding/removing fields must be done carefully so that the signature matches all fields.
// It also makes backwards compatibility difficult.
// read the code in auth-service/.../authbe/sign.go and go-easyops/.../auth/sign_verify.go
type User struct {
	ID             string   `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Email          string   `protobuf:"bytes,2,opt,name=Email" json:"Email,omitempty"`
	FirstName      string   `protobuf:"bytes,3,opt,name=FirstName" json:"FirstName,omitempty"`
	LastName       string   `protobuf:"bytes,4,opt,name=LastName" json:"LastName,omitempty"`
	Password       string   `protobuf:"bytes,5,opt,name=Password" json:"Password,omitempty"`
	Groups         []*Group `protobuf:"bytes,6,rep,name=Groups" json:"Groups,omitempty"`
	Abbrev         string   `protobuf:"bytes,7,opt,name=Abbrev" json:"Abbrev,omitempty"`
	Active         bool     `protobuf:"varint,8,opt,name=Active" json:"Active,omitempty"`
	ServiceAccount bool     `protobuf:"varint,9,opt,name=ServiceAccount" json:"ServiceAccount,omitempty"`
	EmailVerified  bool     `protobuf:"varint,10,opt,name=EmailVerified" json:"EmailVerified,omitempty"`
	//
	// 0:not signed, otherwise version:
	// Version 2: ed25519 over ID, Email, FirstName, LastName, Active,Abbrev, GroupIDs, ServiceAccount, EmailVerified
	SignatureVersion uint32 `protobuf:"varint,11,opt,name=SignatureVersion" json:"SignatureVersion,omitempty"`
	SignedAt         uint32 `protobuf:"varint,12,opt,name=SignedAt" json:"SignedAt,omitempty"`
	SignatureID      []byte `protobuf:"bytes,13,opt,name=SignatureID,proto3" json:"SignatureID,omitempty"`
	SignatureFull    []byte `protobuf:"bytes,14,opt,name=SignatureFull,proto3" json:"SignatureFull,omitempty"`
	OrganisationID   string `protobuf:"bytes,15,opt,name=OrganisationID" json:"OrganisationID,omitempty"`
}

func (m *User) Reset()                    { *m = User{} }
func (m *User) String() string            { return proto.CompactTextString(m) }
func (*User) ProtoMessage()               {}
func (*User) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{3} }

func (m *User) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *User) GetEmail() string {
	if m != nil {
		return m.Email
	}
	return ""
}

func (m *User) GetFirstName() string {
	if m != nil {
		return m.FirstName
	}
	return ""
}

func (m *User) GetLastName() string {
	if m != nil {
		return m.LastName
	}
	return ""
}

func (m *User) GetPassword() string {
	if m != nil {
		return m.Password
	}
	return ""
}

func (m *User) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

func (m *User) GetAbbrev() string {
	if m != nil {
		return m.Abbrev
	}
	return ""
}

func (m *User) GetActive() bool {
	if m != nil {
		return m.Active
	}
	return false
}

func (m *User) GetServiceAccount() bool {
	if m != nil {
		return m.ServiceAccount
	}
	return false
}

func (m *User) GetEmailVerified() bool {
	if m != nil {
		return m.EmailVerified
	}
	return false
}

func (m *User) GetSignatureVersion() uint32 {
	if m != nil {
		return m.SignatureVersion
	}
	return 0
}

func (m *User) GetSignedAt() uint32 {
	if m != nil {
		return m.SignedAt
	}
	return 0
}

func (m *User) GetSignatureID() []byte {
	if m != nil {
		return m.SignatureID
	}
	return nil
}

func (m *User) GetSignatureFull() []byte {
	if m != nil {
		return m.SignatureFull
	}
	return nil
}

func (m *User) GetOrganisationID() string {
	if m != nil {
		return m.OrganisationID
	}
	return ""
}

type Group struct {
	ID   string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Name string `protobuf:"bytes,2,opt,name=Name" json:"Name,omitempty"`
	// a free text field describing the usage of this group
	Description string `protobuf:"bytes,3,opt,name=Description" json:"Description,omitempty"`
}

func (m *Group) Reset()                    { *m = Group{} }
func (m *Group) String() string            { return proto.CompactTextString(m) }
func (*Group) ProtoMessage()               {}
func (*Group) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{4} }

func (m *Group) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *Group) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Group) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type GroupList struct {
	Groups []*Group `protobuf:"bytes,1,rep,name=Groups" json:"Groups,omitempty"`
}

func (m *GroupList) Reset()                    { *m = GroupList{} }
func (m *GroupList) String() string            { return proto.CompactTextString(m) }
func (*GroupList) ProtoMessage()               {}
func (*GroupList) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{5} }

func (m *GroupList) GetGroups() []*Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type AddToGroupRequest struct {
	UserID  string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	GroupID string `protobuf:"bytes,2,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *AddToGroupRequest) Reset()                    { *m = AddToGroupRequest{} }
func (m *AddToGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*AddToGroupRequest) ProtoMessage()               {}
func (*AddToGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{6} }

func (m *AddToGroupRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *AddToGroupRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

type RemoveFromGroupRequest struct {
	UserID  string `protobuf:"bytes,1,opt,name=UserID" json:"UserID,omitempty"`
	GroupID string `protobuf:"bytes,2,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *RemoveFromGroupRequest) Reset()                    { *m = RemoveFromGroupRequest{} }
func (m *RemoveFromGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*RemoveFromGroupRequest) ProtoMessage()               {}
func (*RemoveFromGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{7} }

func (m *RemoveFromGroupRequest) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *RemoveFromGroupRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

type ListGroupRequest struct {
	GroupID              string `protobuf:"bytes,1,opt,name=GroupID" json:"GroupID,omitempty"`
	IncludeInactiveUsers bool   `protobuf:"varint,2,opt,name=IncludeInactiveUsers" json:"IncludeInactiveUsers,omitempty"`
}

func (m *ListGroupRequest) Reset()                    { *m = ListGroupRequest{} }
func (m *ListGroupRequest) String() string            { return proto.CompactTextString(m) }
func (*ListGroupRequest) ProtoMessage()               {}
func (*ListGroupRequest) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{8} }

func (m *ListGroupRequest) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

func (m *ListGroupRequest) GetIncludeInactiveUsers() bool {
	if m != nil {
		return m.IncludeInactiveUsers
	}
	return false
}

type UserListResponse struct {
	Users []*User `protobuf:"bytes,1,rep,name=Users" json:"Users,omitempty"`
}

func (m *UserListResponse) Reset()                    { *m = UserListResponse{} }
func (m *UserListResponse) String() string            { return proto.CompactTextString(m) }
func (*UserListResponse) ProtoMessage()               {}
func (*UserListResponse) Descriptor() ([]byte, []int) { return fileDescriptor1, []int{9} }

func (m *UserListResponse) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthResponse)(nil), "auth.AuthResponse")
	proto.RegisterType((*SignedAuthResponse)(nil), "auth.SignedAuthResponse")
	proto.RegisterType((*SignedUser)(nil), "auth.SignedUser")
	proto.RegisterType((*User)(nil), "auth.User")
	proto.RegisterType((*Group)(nil), "auth.Group")
	proto.RegisterType((*GroupList)(nil), "auth.GroupList")
	proto.RegisterType((*AddToGroupRequest)(nil), "auth.AddToGroupRequest")
	proto.RegisterType((*RemoveFromGroupRequest)(nil), "auth.RemoveFromGroupRequest")
	proto.RegisterType((*ListGroupRequest)(nil), "auth.ListGroupRequest")
	proto.RegisterType((*UserListResponse)(nil), "auth.UserListResponse")
}

func init() { proto.RegisterFile("golang.conradwood.net/apis/auth/auth.proto", fileDescriptor1) }

var fileDescriptor1 = []byte{
	// 609 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x54, 0xd1, 0x4e, 0x1b, 0x3b,
	0x10, 0xd5, 0x42, 0x12, 0x92, 0x49, 0xe0, 0xe6, 0x5a, 0x08, 0x59, 0x57, 0x57, 0xdc, 0xbd, 0x5b,
	0x54, 0x45, 0x3c, 0x84, 0x8a, 0xf6, 0xb9, 0x52, 0xaa, 0x40, 0xb5, 0x15, 0xb4, 0x68, 0xa1, 0x3c,
	0xd7, 0xd9, 0x75, 0x83, 0xd5, 0x8d, 0x9d, 0xda, 0xde, 0xf0, 0x3b, 0xfd, 0x80, 0xfe, 0x52, 0xff,
	0xa5, 0xf2, 0xd8, 0x2c, 0x1b, 0x68, 0xd5, 0x87, 0x4a, 0x7d, 0x59, 0xed, 0x39, 0x73, 0x66, 0x7c,
	0xc6, 0x63, 0x0d, 0x1c, 0xce, 0x55, 0xc9, 0xe4, 0x7c, 0x9c, 0x2b, 0xa9, 0x59, 0x71, 0xab, 0x54,
	0x31, 0x96, 0xdc, 0x1e, 0xb1, 0xa5, 0x30, 0x47, 0xac, 0xb2, 0x37, 0xf8, 0x19, 0x2f, 0xb5, 0xb2,
	0x8a, 0xb4, 0xdc, 0x7f, 0xf2, 0x25, 0x82, 0xc1, 0xa4, 0xb2, 0x37, 0x19, 0x37, 0x4b, 0x25, 0x0d,
	0x27, 0xbb, 0xd0, 0xbe, 0x66, 0xa5, 0x28, 0x68, 0x14, 0x47, 0xa3, 0x6e, 0xe6, 0x01, 0x39, 0x80,
	0xed, 0x8b, 0x6a, 0x56, 0x8a, 0xfc, 0x9c, 0x1b, 0xc3, 0xe6, 0x9c, 0x6e, 0xc4, 0xd1, 0xa8, 0x97,
	0xad, 0x93, 0x64, 0x1f, 0xe0, 0x4c, 0xcd, 0xef, 0x24, 0x9b, 0x28, 0x69, 0x30, 0x64, 0x1f, 0x5a,
	0xef, 0x0d, 0xd7, 0xb4, 0x15, 0x47, 0xa3, 0xfe, 0x31, 0x8c, 0xd1, 0x8d, 0x63, 0x32, 0xe4, 0xdd,
	0xd9, 0x57, 0xea, 0x13, 0x97, 0xb4, 0x8d, 0xa9, 0x1e, 0x24, 0x5f, 0x23, 0x20, 0x97, 0x62, 0x2e,
	0x79, 0xf1, 0xc7, 0x8c, 0x1e, 0xac, 0x19, 0x1d, 0x7a, 0xa3, 0xde, 0xc3, 0x2f, 0xed, 0xbe, 0x04,
	0xb8, 0x57, 0x12, 0x12, 0x2a, 0x39, 0x93, 0x83, 0x90, 0xf7, 0x2f, 0xf4, 0x9c, 0x82, 0xd9, 0x4a,
	0x7b, 0x7f, 0x83, 0xec, 0x9e, 0x48, 0xbe, 0x6d, 0xfa, 0x14, 0xb2, 0x03, 0x1b, 0xe9, 0x14, 0x13,
	0x7b, 0xd9, 0x46, 0x3a, 0x75, 0xc7, 0x9d, 0x2c, 0x98, 0x28, 0x43, 0x4b, 0x1e, 0xb8, 0x62, 0xa7,
	0x42, 0x1b, 0xfb, 0x96, 0x2d, 0xee, 0x3a, 0xb9, 0x27, 0xc8, 0x3f, 0xd0, 0x3d, 0x63, 0x21, 0xd8,
	0xc2, 0x60, 0x8d, 0x5d, 0xec, 0x82, 0x19, 0x73, 0xab, 0x74, 0x11, 0x3a, 0xa8, 0x31, 0x79, 0x02,
	0x9d, 0xd7, 0x5a, 0x55, 0x4b, 0x43, 0x3b, 0xf1, 0xe6, 0xa8, 0x7f, 0xdc, 0xf7, 0x57, 0x80, 0x5c,
	0x16, 0x42, 0x64, 0x0f, 0x3a, 0x93, 0xd9, 0x4c, 0xf3, 0x15, 0xdd, 0xc2, 0xf4, 0x80, 0x90, 0xcf,
	0xad, 0x58, 0x71, 0xda, 0xc5, 0xd1, 0x04, 0x44, 0x9e, 0xc2, 0xce, 0x25, 0xd7, 0x2b, 0x91, 0xf3,
	0x49, 0x9e, 0xab, 0x4a, 0x5a, 0xda, 0xc3, 0xf8, 0x03, 0xd6, 0xcd, 0x10, 0x7b, 0xbb, 0xe6, 0x5a,
	0x7c, 0x14, 0xbc, 0xa0, 0x80, 0xb2, 0x75, 0x92, 0x1c, 0xc2, 0xb0, 0xbe, 0xb4, 0x6b, 0xae, 0x8d,
	0x50, 0x92, 0xf6, 0xe3, 0x68, 0xb4, 0x9d, 0x3d, 0xe2, 0x5d, 0xab, 0xe1, 0x05, 0x59, 0x3a, 0x40,
	0x4d, 0x8d, 0x49, 0x0c, 0xfd, 0x5a, 0x9f, 0x4e, 0xe9, 0x36, 0xce, 0xa3, 0x49, 0x39, 0x3f, 0x35,
	0x3c, 0xad, 0xca, 0x92, 0xee, 0xa0, 0x66, 0x9d, 0x74, 0xdd, 0xbd, 0xd3, 0x73, 0x26, 0x85, 0x61,
	0x56, 0x28, 0x99, 0x4e, 0xe9, 0x5f, 0x78, 0x2b, 0x0f, 0xd8, 0xe4, 0x1c, 0xda, 0x78, 0x7f, 0x8f,
	0xe6, 0x4b, 0xa0, 0x85, 0x73, 0xf2, 0xe3, 0xc5, 0x7f, 0x67, 0x6e, 0xca, 0x4d, 0xae, 0xc5, 0xd2,
	0x65, 0x87, 0xf9, 0x36, 0xa9, 0xe4, 0x19, 0xf4, 0xb0, 0xdc, 0x99, 0x30, 0xb6, 0x31, 0xb6, 0xe8,
	0xa7, 0x63, 0x4b, 0x4e, 0xe0, 0xef, 0x49, 0x51, 0x5c, 0x29, 0xcf, 0xf2, 0xcf, 0x15, 0x37, 0xd6,
	0xcd, 0xcc, 0x3d, 0xba, 0xda, 0x50, 0x40, 0x84, 0xc2, 0x16, 0xea, 0xd2, 0x69, 0xf0, 0x75, 0x07,
	0x93, 0x37, 0xb0, 0x97, 0xf1, 0x85, 0x5a, 0xf1, 0x53, 0xad, 0x16, 0xbf, 0x59, 0xeb, 0x03, 0x0c,
	0x9d, 0xff, 0xb5, 0x2a, 0x0d, 0x75, 0xb4, 0xa6, 0x26, 0xc7, 0xb0, 0x9b, 0xca, 0xbc, 0xac, 0x0a,
	0x9e, 0x4a, 0x86, 0x4f, 0xcb, 0x1d, 0x60, 0xb0, 0x68, 0x37, 0xfb, 0x61, 0x2c, 0x79, 0x01, 0x43,
	0xf7, 0xe3, 0x4e, 0xa9, 0x37, 0x48, 0x0c, 0x6d, 0x9f, 0xe8, 0x2f, 0xab, 0xb9, 0x8f, 0x7c, 0xe0,
	0xd5, 0xff, 0xf0, 0x9f, 0xe4, 0xb6, 0xb9, 0x4e, 0xc3, 0x82, 0x75, 0x1b, 0x15, 0xe5, 0xb3, 0x0e,
	0x6e, 0xd3, 0xe7, 0xdf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x7c, 0xdf, 0xca, 0x03, 0x7b, 0x05, 0x00,
	0x00,
}
